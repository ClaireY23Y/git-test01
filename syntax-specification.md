# Syntax Specification

## Using sql syntax generated by jsql

Use sql.toSql() to check if the jsql you input is correct. The following is an example:

```
var user = jsql.template['system.user'];
var sql = jsql.select().from(user);
sql.toSql()
print:>>>
select * from system_user;
```

## Selecting All the Data of Template

Template must use object instead of string as string stands for constant.

Too much data may cause server clash. If no limit clauses are added, the default range is the first 20 items with a maximum value of 5000. Exceeding of the maximum value will induce error.

If the namespace of a template is not filled in, selection of template is conducted among the namespace of the current app. If no item can be found, selection of a template is then conducted among the system namespace. If no item can be found, an error will be reported.

```
// Get template
var user = jsql.template.user;
// Select staff，the first 20 items are returned by default
var sql = jsql.select().from(user);
// Execute search command
repo.query(sql);

// Designate the namespace of template
var absence = jsql.template["supos_work.absence"];
// Select staff，the first 20 items are returned by default
sql = jsql.select().from(absence);
// Execute search command
repo.query(sql);
```

## Selecting Data with Designated Attributes

Attributes must be acquired by template object rather than using string because string stands for contant.

```
// Select the name and age of all the staff
var user = jsql.template.user;
var sql = jsql.select(user.name, user.age).from(user);

// Execute search command

repo.query(sql);
```

## Results

* If the attributes returned include the name and age of the staff, the results returned are as follows:

```
{
    "columns": [
        {
            "templateNamespace": "employ",
            "templateEnName": "user",
            "attributeEnName": "name",
            "fullName": "supos_employ.user.name",
        },
        {
            "templateNamespace": "employ",
            "templateEnName": "user",
            "attributeEnName": "age",
            "fullName": "supos_employ.user.age",
        }
    ],
    "items": [
        ["John", 40],
        ["Jack", 30]
    ]
}
```

* Get data with kv form to cater to front-end components of Tianfang. The returned results are as follows:

```
// Get the name and age of all the staff
var user = jsql.template.user;
var sql = jsql.select(user.name, user.age).from(user);
// query can designate a particular dataFormat parameter to modify the format of returned data to cater to different scenarios,e.g. Tianfang forms
// Currently dataFormat only suppirts kv: the results are returned with the form of {"list":[],"pagination":{}} data is k-v struture, k is fullName, and v is the attribute value
repo.query(sql, "kv");
```

```
{
    "list": [
        {
            "supos_employ.user.name": "John",
            "supos_employ.user.age": 40
        },
        {
            "supos_employ.user.name": "李四",
            "supos_employ.user.age": 30
        }
    ],
    "pagination": {
        "current": 1,
        "pageSize": 20,
        "total": 2
    }
}
```

* templateNamespace：namespace of template
* templateEnName：alias of template
* attributeEnName：alias of attribute
* fullName：consisting above three fields，form：namespace of template.alias of template.alias of attribute.
* fullName：an attribute that can be the unique identification of key.
* Attributes with namespaces are not supported supported. All the English names of the attributes in the current template and parent template must be unique. If not, only the attributes of current template can be located.

## Joint Query of Data from Multiple Templates

Join type:

* join(t, onCondition) // inner join
* leftJoin(t, onCondition)
* rightJoin(t, onCondition)
* fullJoin(t, onCondition)

## Fuzzy Query

```
// Select all the staff with name starting by letter J. Note that you need to designate %

var sql = jsql.select().from(user).where(user.name.like("J%"));

// Select all the note for leaves with the reason for leave containing sick

var sql = jsql.select().from(absence).where(absence.reason.like("%sick%"));
```

## Comparison Operation

```
// Select all the staff older than 20
var sql = jsql.select().from(user).where(user.age.gt(20));
// Select all the note for leaves with less than three days of absence 
var sql = jsql.select().from(absence).where(absence.absence_days.lt(3));

Supported operators are as follows:
```

* \= equals eq：user.age.eq(10)
* \> equals gt：user.age.gt(10)
* \>=equals ge：user.age.ge(10)
* < equals lt：user.age.lt(10)
* <= equals le：user.age.le(10)
* != equals ne：user.age.ne(10)

## Logical Operators

* and

```
// Select all the staff in department two who are older than 20
var sql = jsql.select().from(user).where(user.age.gt(20).and(user.dep.eq('Department2')));
```

* or

```
// Select all the staff older than 20 or younger than 40
var sql = jsql.select().from(user).where(user.age.gt(20).or(user.age.lt(40)));
```

* not

```
// Select all the staff that are not from department two
var sql = jsql.select().from(user).where(user.dep.eq('department2').not());
```

## Constant Expressions

Sometimes constant expressions are needed to combine with sql, e.g. where true and user.age.gt(20).

```
// Input parameter to conbine with sql
// Two parameters: min_age, name_keyword，both can be null. If the parameters are null，data will not be filtered.
var absence = jsql.template.absence;
var user = jsql.template.user;

var condition = jsql.inline(true);
// Use inline to generate constant expressions.Varous ways can be used to combine with sql.
if (min_age !== null) {
    condition = condition.and(user.age.gt(min_age));
}
if (name_keyword !== null && name_keyword !== '') {
    condition = condition.and(user.name.like('%' + name_keyword + '%'));
}

var sql = jsql.select().from(user).where(condition);

repo.query(sql);
```

### Grouping expressions

Complex expressions need to be grouped by using brackets. Grouping is performed by using group function.

```
//Select all the staff older than 20 and younger than 30 or older than 40 and younger than 50.
var sql = jsql.select().from(user).where(jsql.group(user.age.gt(20).and(user.age.lt(30))).or(jsql.group(user.age.gt(40).and(user.age.lt(50)))));
// Corresponding sql: select * from user where (user.age > 20 and user.age < 30) or (user.age > 40 and user.age < 50)

```

## Select Range

### in, notlin

```
//Select all the staff of department two or three
var sql = jsql.select().from(user).where(user.dep.in('department2','department3'));
//Select all the staff that are not from department two or three
var sql = jsql.select().from(user).where(user.dep.notIn('department2','department3'));
```

### between, notBetween

```
// Select all the staff older than 20 and younger than 30 (including 20 and 30)
var sql = jsql.select().from(user).where(user.age.between(20, 30))
// Select all the staff that are not older than 20 and younger than 30
var sql = jsql.select().from(user).where(user.age.notBetween(20, 30))
```

## Case Statement

* caseWhen
* caseWhenEq&#x20;

```
// Select the age range of all the staff，0-20: teenager，20-30: adolescence，30+ middle age
var sql = jsql.select(jsql.caseWhen(user.age.lt(20), 'teenager').when(user.age.between(20, 30), 'adolescence').el('middle age')).from(user);
// Select the age of all the staff. Return younger if the value equals 30; Return older if the value equals 40; Otherwise, Return unknown.
```



### between, notBetween

```
// Select all the staff 查询年龄在20到30之间的所有员工(包含20和30)
var sql = jsql.select().from(user).where(user.age.between(20, 30))
// 查询年龄不在20到30之间的所有员工
var sql = jsql.select().from(user).where(user.age.notBetween(20, 30))
```



## Grouping Query Results

```
// Calculate the staff number of each department
var sql = jsql.select(user.dep, user.uid.count()).from(user).groupBy(user.dep);
```

## Filtered Results

```
// Calculate the staff number of each department and Return results with the number greater than 100
var sql = jsql.select(user.dep, 
user.uid.count()).from(user).groupBy(user.dep).having(user.uid.count().gt(100));
```

## Ordering Results

```
// Select all the satff. Order by uid with ascending order(the default order is ascending order)
var sql = jsql.select().from(user).orderBy(user.uid);
// Select all the satff. Order by uid with descending order
var sql = jsql.select().from(user).orderByDesc(user.uid);
// Select all the satff. Order by uid with ascending order and by name with descending order
var sql = jsql.select().from(user).orderBy(user.uid).orderByDesc(user.name);
```

## Limiting Data Range

Without limit, the system adds limit (20) by default (i.e. get the first 20 items. The maximum value of limit is 50000). Limit(20,20) means to start from 20 and to get the data from 20-40. The first _20_ stands for data address, the latter stands for the length of data. Paging can also be used to limit data to cater to front-end.&#x20;

<pre><code>// Select staff and return the data of first 20 staff; order the result by uid with  ascending order.
var sql = jsql.select().from(user).orderBy(user.uid).limit(20);
// Select staff, skip the first 20 staff, order the results by ascending order. Rerurn the staff from 20-40.
var sql = jsql.select().from(user).orderBy(user.uid).limit(20, 20);
<strong>//Select by paging 
</strong>var sql = jsql.select().from(user).orderBy(user.uid).pageBy(2, 20); 
// current = 2, pageSize = 20</code></pre>

## Selecting Distinct Statement

```
// Select staff with distinct name
var sql = jsql.select(user.name.distinct()).from(user);
// Select staff with distinct field
var sql = jsql.select().distinctAll().from(user);
```

## sql function and operator

### Arithmetic Operation

```
// Return the result with the age of the staff 查询所有员工的年龄加上10的结果
var sql = jsql.select(user.age.add(10)).from(user);
```

Supported arithmetic operator:

* \+ add：user.age.add(10), sql: user.age + 10
* \- sub：user.age.sub(10), sql: user.age - 10
* \*user.age.mul(10) , sql: user.age \* 10
* / div：user.age.div(10), sql: user.age / 10&#x20;
* % mod：user.age.mod(10), sql: user.age % 10

### Arithmetic Function

* abs

Function: get absolute value

Null parameter

```
// Select all the notes for leave. Return the absolute value of absence days minus 7 
var sql = jsql.select(absence.absence_days.sub(7).abs()).from(absence);
```

### String Function

* substr(position, length)

function: subtract string

position： integer, the index of the character to be subtracted

length: integer, length of subtraction

```
// Select all the notes for leave. Subtract the first 30 characters of leave reason
var sql = jsql.select(absence.reason.substr(1, 30)).from(absence);
```

### Aggregate Function

* count()

function: calculate quantity

no parameters

```
// Get number of notes for leave 
var sql = jsql.select(absence.code.count()).from(absence);
```

* avg()

function: get average value

no parameters

```
// Get average value of absentce days 
var sql = jsql.select(absence.absence_days.avg()).from(absence);
```

* max()

function: get maximum value

no parameters

```
// Get the longest duration of absence days 
var sql = jsql.select(absence.absence_days.max()).from(absence);
```

* min()

function: get minimum value

no parameters

```
// Get the longest duration of absence days 
var sql = jsql.select(absence.absence_days.max()).from(absence);
```

### Date Function

* dateFormat(format)

function: format the date

format: form. Please refer to mysql documents for details ：https://www.mysqltutorial.org/mysql-date/\_format/

```
// Get the staff id and the employ time: date format: 2020-10-10 11:30:03
var sql =
jsql.select(user.employ_time.dateFormat('%Y-%m-%d %H:%i:%S')).from(user);
```

### Inserting Data

```
// Inserting two staff
// Fields and values correspond in order
var sql = jsql.insert(user)
.columns(user.uid, user.name, user.age, user.dep, user.employ_time)
.values(    ['1', "John", 20, 'department2', '2020-10-10 11:30:03'],    ['2', "Jack", 30, 'department2', '2020-10-10 11:30:03']);

// Return the number of the inserted items
repo.insert(sql);
```

### Updating Data

Note that update command must have where condition to prevent the undesirable update of data.

```
// Update all the staff in department two, age plus two.
var sql = jsql.update(user)
.set({age: user.age.add(1)})
.where(user.dep.eq('department2'));

// Return the number of updated data
repo.update(sql);
```

### Deleting Data

Delete command must contain where condition to avoid accidental deletion of all the data.

```
// Delete note for leave with its number being 001
var sql = jsql.delete(absence).where(absence.code.eq('001'));
// Return the number of updated data
repo.delete(sql);
```

### Transaction

The transaction is used to control the consistency of multiple data manually to ensure the entirety of success or failure.

The current level of isolation is repeatable-read which eliminates Non-Repeatable Read but still has phantom in it.

```
//Create transaction
var tx = services.DataTableService.createTransaction();  
//Commit transaction
tx.commit();  
// Rollback transaction
tx.rollback();  
// Close transaction
tx.close();


// Insert two staff; delete one note for leave and ensure the entirety of success or failure

// Create transaction
var tx = services.DataTableService.createTransaction();

// Update data
var sql = jsql.insert(user)
.columns(user.uid, user.name, user.age, user.dep, user.employ_time)
.values(
    ['1', "John", 20, 'department2', '2020-10-10 11:30:03'],
    ['2', "Jack", 30, 'department2', '2020-10-10 11:30:03']
);
repo.insert(sql);


sql = jsql.delete(absence).where(absence.code.eq('001'));

// Commit transaction
tx.commit();
```
